* Future

- What to do with the logTag

** `LISTEN_FDS` and `--preserve-fds` command line

Does not seem to be used in Kata runtime. `CreateOps.ExtraFiles` but only for runc.go

Podman fix for #10443:
https://github.com/containers/podman/issues/10443
https://github.com/containers/podman/pull/10448/commits/c3bdae5cf924078c3a1447260babaa8e2843d6c6


* Commands

~/Work/ociplex/containers/podman
bin/podman --log-level=debug                                            run -it fedora bash > running-conmon.log 2>&1
bin/podman --log-level=debug --runtime /usr/bin/containerd-shim-kata-v2 run -it fedora bash > running-shim.log 2>&1


* Notes about inner workings

** Data flow

In containerd, `-address` argument comes from the following chain
- (CommandConfig) config.Address (v2/shim/util.go Command(...))
- (binary) b.containerAddress (e.g. v2/binary.go)
- (shimBinaryConfig) config.address (v2/binary.go)
- (ShimManager) m.containerAddress (v2/manager.go, v2/shim_load.go)
- (ManagerConfig) config.Address (v2/manager.go)
- (plugin.InitContext) ic.Properties[plugins.PropertyGRPCAddress] (v2/manager.go)
   - From addressFlag (v2/shim/shim.go) which is -address argument to shim
	flag.StringVar(&addressFlag, "address", "", "grpc address back to main containerd")
   - From config.GRPC.Address in server/server.go
        from toml:grpc (GRCPConfig) GRPC

The same for TTRPCAddress, which ultimately comes from PropertyTTRPCAddress.

** Property names

Property names are constants defined as io.containerd.plugin.grpc.address and "io.containerd.plugin.ttrpc.address".

** TTRPC from GRPC

GRPC cannot be empty

		if config.GRPC.Address == "" {
			return fmt.Errorf("grpc address cannot be empty: %w", errdefs.ErrInvalidArgument)
		}

but TTPRC can be built from it:

		if config.TTRPC.Address == "" {
			// If TTRPC was not explicitly configured, use defaults based on GRPC.
			config.TTRPC.Address = config.GRPC.Address + ".ttrpc"
			config.TTRPC.UID = config.GRPC.UID
			config.TTRPC.GID = config.GRPC.GID
		}

** TOML fields

// GRPCConfig provides GRPC configuration for the socket
type GRPCConfig struct {
	Address        string `toml:"address"`
	TCPAddress     string `toml:"tcp_address"`
	TCPTLSCA       string `toml:"tcp_tls_ca"`
	TCPTLSCert     string `toml:"tcp_tls_cert"`
	TCPTLSKey      string `toml:"tcp_tls_key"`
	UID            int    `toml:"uid"`
	GID            int    `toml:"gid"`
	MaxRecvMsgSize int    `toml:"max_recv_message_size"`
	MaxSendMsgSize int    `toml:"max_send_message_size"`
}

// TTRPCConfig provides TTRPC configuration for the socket
type TTRPCConfig struct {
	Address string `toml:"address"`
	UID     int    `toml:"uid"`
	GID     int    `toml:"gid"`
}


** Documentation:

- **address** (Default: "/run/containerd/containerd.sock")
- **tcp_address**
- **tcp_tls_cert**
- **tcp_tls_key**
- **uid** (Default: 0)
- **gid** (Default: 0)
- **max_recv_message_size**
- **max_send_message_size**

** Sample config:

```toml
version = 2

root = "/var/lib/containerd"
state = "/run/containerd"
oom_score = 0
imports = ["/etc/containerd/runtime_*.toml", "./debug.toml"]

[grpc]
  address = "/run/containerd/containerd.sock"
  uid = 0
  gid = 0

[debug]
  address = "/run/containerd/debug.sock"
  uid = 0
  gid = 0
  level = "info"

[metrics]
  address = ""
  grpc_histogram = false

[cgroup]
  path = ""

[plugins]
  [plugins."io.containerd.monitor.v1.cgroups"]
    no_prometheus = false
  [plugins."io.containerd.service.v1.diff-service"]
    default = ["walking"]
  [plugins."io.containerd.gc.v1.scheduler"]
    pause_threshold = 0.02
    deletion_threshold = 0
    mutation_threshold = 100
    schedule_delay = 0
    startup_delay = "100ms"
  [plugins."io.containerd.runtime.v2.task"]
    platforms = ["linux/amd64"]
    sched_core = true
  [plugins."io.containerd.service.v1.tasks-service"]
    blockio_config_file = ""
    rdt_config_file = ""
```


** So as a hack, probably OK to have:

address = /run/podman/podman-$pid.sock
ttrpcAddress = /run/podman/podman-$pid.sock.ttrpc


* Starting the shim

** Sequence
  - Need to have started a server on the containerd address / ttrpc address

1 - startShim (v2/manager.go)
  - b := shimBinary(...)
2- (binary) Start
3 - client.Command(...)  (v2/shim/util.go)
- exec.CommandContext
4- openShimLog (see below) and run copy of command output in gofunc
5-cmd.CombinedOutput()

** Setpgid
- getSysProcAttr (v2/shim/util_unix.go)

        cmd.SysProcAttr = ...
  	return &syscall.SysProcAttr{
		Setpgid: true,
	}

        Same thing for conmon:

      	cmd := exec.Command(r.conmonPath, args...)
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true,
	}

** stdin

cmd.Stdin = bytes.NewReader(d) where d is a [] bytes marshalled from opts
protobuf.FromAny(topts)

	topts := opts.TaskOptions
	if topts == nil || topts.GetValue() == nil {
		topts = opts.RuntimeOptions
	}


** openShimLog

	// Windows needs a namespace when openShimLog


func openShimLog(ctx context.Context, bundle *Bundle, _ func(string, time.Duration) (net.Conn, error)) (io.ReadCloser, error) {
	return fifo.OpenFifo(ctx, filepath.Join(bundle.Path, "log"), unix.O_RDWR|unix.O_CREAT|unix.O_NONBLOCK, 0700)
}


	// open the log pipe and block until the writer is ready
	// this helps with synchronization of the shim
	// copy the shim's logs to containerd's output
	go func() {
		defer f.Close()
		_, err := io.Copy(os.Stderr, f)
		// To prevent flood of error messages, the expected error
		// should be reset, like os.ErrClosed or os.ErrNotExist, which
		// depends on platform.
		err = checkCopyShimLogError(ctx, err)
		if err != nil {
			log.G(ctx).WithError(err).Error("copy shim log")
		}
	}()



* Tricks

cmd.Stdin = bytes.NewReader(d) where d is a [] bytes


* Sandbox API

type TTRPCSandboxService interface {
	CreateSandbox(context.Context, *CreateSandboxRequest) (*CreateSandboxResponse, error)
	StartSandbox(context.Context, *StartSandboxRequest) (*StartSandboxResponse, error)
	Platform(context.Context, *PlatformRequest) (*PlatformResponse, error)
	StopSandbox(context.Context, *StopSandboxRequest) (*StopSandboxResponse, error)
	WaitSandbox(context.Context, *WaitSandboxRequest) (*WaitSandboxResponse, error)
	SandboxStatus(context.Context, *SandboxStatusRequest) (*SandboxStatusResponse, error)
	PingSandbox(context.Context, *PingRequest) (*PingResponse, error)
	ShutdownSandbox(context.Context, *ShutdownSandboxRequest) (*ShutdownSandboxResponse, error)
	SandboxMetrics(context.Context, *SandboxMetricsRequest) (*SandboxMetricsResponse, error)
}

* Starting the GRPC and TTRPC server
